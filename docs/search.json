[
  {
    "objectID": "posts/2.상관계수ex.html",
    "href": "posts/2.상관계수ex.html",
    "title": "2. 상관계수 ex",
    "section": "",
    "text": "- 상관계수\n\nX,Y에 상수를 곱해줘도 그대로, 변하지 않음\n기울기만 변함\n\n\nx = rnorm(100)\ny = rnorm(100) + 2*x\nplot(x,y)\ncor(x,y)\npoints(2*x, 0.25*y, col='red') \ncor(2*x, 0.25*y)\n\n0.881075342687499\n\n\n0.881075342687499\n\n\n\n\n\n\n\n\n\n- 상관계수\n\naX, bY 의 상관계수에서 aXb &lt;0 이면\nCorr(aX,bY) = -Corr(X,Y)\n상관계수 크기는 그대로\n기울기만 변함\n\n\nx = rnorm(100)\ny = rnorm(100) + 2*x\nplot(x,y)\ncor(x,y)\npoints(-2*x, 0.1*y, col='red') \ncor(-2*x, 0.1*y)\n\n0.906127948410664\n\n\n-0.906127948410664\n\n\n\n\n\n\n\n\n\n- 상관계수 : 기울기와 관련 X, 직선에 얼마나 몰려있는가"
  },
  {
    "objectID": "posts/3.DC_HW1.html",
    "href": "posts/3.DC_HW1.html",
    "title": "3. DC HW1",
    "section": "",
    "text": "- 표본추출, 히스토그램\n\nmean = 3 으로 지정\n\n\nnormal_random &lt;- rnorm(n = 500, mean = 3)\nhist(normal_random)\n\n\n\n\n\n\n\n\n- 표본평균\n\nmean(normal_random)\n\n3.0025640596709\n\n\n\n\n\n- 표본추출, 히스토그램\n\n포아송 분포에서 \\(E(X) = \\lambda\\) 이므로 \\(\\lambda\\) = 3으로 지정\n\n\npoisson_random &lt;- rpois(n = 500, lambda = 3)\nhist(poisson_random)\n\n\n\n\n\n\n\n\n- 표본평균\n\nmean(poisson_random)\n\n2.874\n\n\n\n\n\n- 표본추출, 히스토그램\n\n이항분포에서 \\(E(X) = np =\\) 3이 되어야하고, size : n, prob = p 에 대응되므로 평균을 10 X 0.3 = 3으로 설정\n\n\nbinomial_random &lt;- rbinom(n = 500, size = 10, prob = 0.3)\nhist(binomial_random, breaks = seq(-0.5, 10.5, by = 1))\n\n\n\n\n\n\n\n\n- 표본평균\n\nmean(binomial_random)\n\n3.106\n\n\n\n\n\n- 표본추출, 히스토그램\n\n\\(GAM(\\alpha,\\beta)\\) 에서 shape : \\(\\alpha\\), rate : \\(\\frac{1}{\\beta}\\) 에 대응\n감마분포에서 \\(E(X) =\\) \\(\\alpha\\) X \\(\\beta =\\) 3이 되어야함\n1(shape) X 3(=1/rate) = 3\n\n\ngamma_random = rgamma(n=500,shape=1,rate=1/3)\nhist(gamma_random)\n\n\n\n\n\n\n\n\n- 표본평균\n\nmean(gamma_random)\n\n2.86597826745274\n\n\n\n\n\n- 표본추출, 히스토그램\n\n지수분포에서 \\(E(X)= \\frac{1}{\\lambda}=\\) 3이 되어야함\nrate= \\(\\lambda\\) 이므로 3(=1/rate)=3\n\n\nexponential_random &lt;- rexp(n = 500, rate = 1/3)\nhist(exponential_random)\n\n\n\n\n\n\n\n\n- 표본평균\n\nmean(exponential_random)\n\n3.00293798354794\n\n\n\n\n\n\n\n\n- 표본추출, 히스토그램\n\n이항분포에서 \\(E(X) = np\\) 이고\n이항분포에서 \\(Var(X) = np(1-p)\\) 임\nnp=3이어야하고 np(1-p)=5여야하므로 (1-p)=5/3 \\(\\to\\) (1-p)&gt;1 \\(\\to\\) 0&gt;p인 상황이므로 불가능하다. p는 확률이므로 &gt;=0\n이항분포에서 평균이 3, 분산이 5인 표본을 추출할 수 없다.\n\n\n\n\n- 표본추출, 히스토그램\n\nmean = 3 으로 지정\n\\(Var(X)=5\\) 이여야 하므로 sd=\\(\\sqrt{Var}\\)=\\(\\sqrt5\\) 로 지정\n\n\nnormal_random &lt;- rnorm(n = 500, mean = 3, sd=sqrt(5))\nhist(normal_random)\n\n\n\n\n\n\n\n\n- 표본평균, 표본분산\n\nmean(normal_random)\nvar(normal_random)\n\n2.92370604471217\n\n\n5.19843216215837\n\n\n\n\n\n- 표본추출, 히스토그램\n\n\\(GAM(\\alpha,\\beta)\\) 에서 shape : \\(\\alpha\\), rate : \\(\\frac{1}{\\beta}\\) 에 대응\n감마분포에서 \\(E(X) =\\) \\(\\alpha\\) X \\(\\beta\\) = 3이 되어야함\n\\(Var(X) =\\) \\(\\alpha\\) X \\(\\beta^2\\) = 5가 되어야함\n\\(\\to\\) \\(\\beta\\) = 5/3, \\(\\alpha\\) = 9/5 \\(\\to\\) rate = 3/5\n\n\ngamma_random = rgamma(n=500,shape=9/5,rate=3/5)\nhist(gamma_random)\n\n\n\n\n\n\n\n\n- 표본평균, 표본 분산\n\nmean(gamma_random)\nvar(gamma_random)\n\n3.15297204789198\n\n\n4.84604724922782"
  },
  {
    "objectID": "posts/3.DC_HW1.html#제공된-코드를-이용하여-아래를-시행하시오.",
    "href": "posts/3.DC_HW1.html#제공된-코드를-이용하여-아래를-시행하시오.",
    "title": "3. DC HW1",
    "section": "",
    "text": "- 표본추출, 히스토그램\n\nmean = 3 으로 지정\n\n\nnormal_random &lt;- rnorm(n = 500, mean = 3)\nhist(normal_random)\n\n\n\n\n\n\n\n\n- 표본평균\n\nmean(normal_random)\n\n3.0025640596709\n\n\n\n\n\n- 표본추출, 히스토그램\n\n포아송 분포에서 \\(E(X) = \\lambda\\) 이므로 \\(\\lambda\\) = 3으로 지정\n\n\npoisson_random &lt;- rpois(n = 500, lambda = 3)\nhist(poisson_random)\n\n\n\n\n\n\n\n\n- 표본평균\n\nmean(poisson_random)\n\n2.874\n\n\n\n\n\n- 표본추출, 히스토그램\n\n이항분포에서 \\(E(X) = np =\\) 3이 되어야하고, size : n, prob = p 에 대응되므로 평균을 10 X 0.3 = 3으로 설정\n\n\nbinomial_random &lt;- rbinom(n = 500, size = 10, prob = 0.3)\nhist(binomial_random, breaks = seq(-0.5, 10.5, by = 1))\n\n\n\n\n\n\n\n\n- 표본평균\n\nmean(binomial_random)\n\n3.106\n\n\n\n\n\n- 표본추출, 히스토그램\n\n\\(GAM(\\alpha,\\beta)\\) 에서 shape : \\(\\alpha\\), rate : \\(\\frac{1}{\\beta}\\) 에 대응\n감마분포에서 \\(E(X) =\\) \\(\\alpha\\) X \\(\\beta =\\) 3이 되어야함\n1(shape) X 3(=1/rate) = 3\n\n\ngamma_random = rgamma(n=500,shape=1,rate=1/3)\nhist(gamma_random)\n\n\n\n\n\n\n\n\n- 표본평균\n\nmean(gamma_random)\n\n2.86597826745274\n\n\n\n\n\n- 표본추출, 히스토그램\n\n지수분포에서 \\(E(X)= \\frac{1}{\\lambda}=\\) 3이 되어야함\nrate= \\(\\lambda\\) 이므로 3(=1/rate)=3\n\n\nexponential_random &lt;- rexp(n = 500, rate = 1/3)\nhist(exponential_random)\n\n\n\n\n\n\n\n\n- 표본평균\n\nmean(exponential_random)\n\n3.00293798354794\n\n\n\n\n\n\n\n\n- 표본추출, 히스토그램\n\n이항분포에서 \\(E(X) = np\\) 이고\n이항분포에서 \\(Var(X) = np(1-p)\\) 임\nnp=3이어야하고 np(1-p)=5여야하므로 (1-p)=5/3 \\(\\to\\) (1-p)&gt;1 \\(\\to\\) 0&gt;p인 상황이므로 불가능하다. p는 확률이므로 &gt;=0\n이항분포에서 평균이 3, 분산이 5인 표본을 추출할 수 없다.\n\n\n\n\n- 표본추출, 히스토그램\n\nmean = 3 으로 지정\n\\(Var(X)=5\\) 이여야 하므로 sd=\\(\\sqrt{Var}\\)=\\(\\sqrt5\\) 로 지정\n\n\nnormal_random &lt;- rnorm(n = 500, mean = 3, sd=sqrt(5))\nhist(normal_random)\n\n\n\n\n\n\n\n\n- 표본평균, 표본분산\n\nmean(normal_random)\nvar(normal_random)\n\n2.92370604471217\n\n\n5.19843216215837\n\n\n\n\n\n- 표본추출, 히스토그램\n\n\\(GAM(\\alpha,\\beta)\\) 에서 shape : \\(\\alpha\\), rate : \\(\\frac{1}{\\beta}\\) 에 대응\n감마분포에서 \\(E(X) =\\) \\(\\alpha\\) X \\(\\beta\\) = 3이 되어야함\n\\(Var(X) =\\) \\(\\alpha\\) X \\(\\beta^2\\) = 5가 되어야함\n\\(\\to\\) \\(\\beta\\) = 5/3, \\(\\alpha\\) = 9/5 \\(\\to\\) rate = 3/5\n\n\ngamma_random = rgamma(n=500,shape=9/5,rate=3/5)\nhist(gamma_random)\n\n\n\n\n\n\n\n\n- 표본평균, 표본 분산\n\nmean(gamma_random)\nvar(gamma_random)\n\n3.15297204789198\n\n\n4.84604724922782"
  },
  {
    "objectID": "posts/3.DC_HW1.html#아래와-같이-표본이-주어져-있다고-한다.",
    "href": "posts/3.DC_HW1.html#아래와-같이-표본이-주어져-있다고-한다.",
    "title": "3. DC HW1",
    "section": "3. 아래와 같이 표본이 주어져 있다고 한다.",
    "text": "3. 아래와 같이 표본이 주어져 있다고 한다.\n\n1) 두 변수 간의 표본과 공분산 그리고 표본 상관계수를 계산하고 해석하시오\n\nx = c(10,20,10,1,3,5,8,9,10)\ny = c(3,5,7,3,2,3,2,2,2)\n\n\ncov(x,y)\ncor(x,y)\n\n4.13888888888889\n\n\n0.442013916579573\n\n\n- 표본 공분산 = 4.138\n\n표본 공분산 : \\(S_{xy} &gt; 0\\) 이므로 x,y는 양의 선형적 관계를 가진다.\n\\(\\to\\) x가 증가할수록 y도 증가하는 경향을 보인다.\n\n- 표본 상관계수 = 0.442\n\n표본 상관계수[-1,1] : \\(r_{xy}\\) &gt; 0 이므로 양의 선형관계를 가진다.\n하지만 |\\(r_{xy}\\)|가 0.4정도로 약한 관계를 보인다.\n\\(\\to\\) x가 증가할수록 y도 증가하는 경향을 보이지만 그 관계는 약하다.\n\n\n\n2) (추가) \\(x\\) \\(\\to\\) \\(2x+1\\), \\(y\\) \\(\\to\\) \\(-y+2\\)로 변환하고 나서 표본 상관계수를 계산하시오.\n\ncor(2*x+1,-y+2)\n\n-0.442013916579573\n\n\n- 표본 상관계수 = -0.442\n\n상관계수의 크기는 선형 변환에 따라 바뀌지 않음\n만약 \\(aX+b, cX+d\\) 에서\n\n\n\\(a\\) X \\(b\\) \\(&lt; 0\\) 이면 \\(\\to\\) Corr(aX,cY) = -Corr(X,Y)\n\n\n\\(a\\) X \\(b\\) \\(&gt; 0\\) 이면 \\(\\to\\) Corr(aX,cY) = Corr(X,Y)\n\n\n여기서 2 X -1 = -2이므로 1)의 경우이므로 표본 상관계수의 부호가 변하였다."
  },
  {
    "objectID": "posts/5.Simulations_ex.html",
    "href": "posts/5.Simulations_ex.html",
    "title": "5. Simulations ex",
    "section": "",
    "text": "Simulation for CLT\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.stats import skewnorm\n\ndef simulate_clt(distribution_type, sample_size, num_samples, **kwargs):\n    \"\"\"\n    중심극한정리(CLT) 시뮬레이션 함수\n\n    Args:\n        distribution_type (str): 모집단 분포 종류 ('uniform', 'exponential', 'normal', 'skewed_left', 'skewed_right')\n        sample_size (int): 각 표본의 크기\n        num_samples (int): 표본의 개수\n        **kwargs: 각 분포에 따른 추가 매개변수\n            - uniform: low (default=0), high (default=1)\n            - exponential: scale (default=1)  (scale = 1/lambda)\n            - normal: loc (default=0), scale (default=1)  (loc: 평균, scale: 표준편차)\n            - binomal: (n, p)\n            - gamma: (shape, scale)\n\n    Returns:\n        None (히스토그램 시각화)\n    \"\"\"\n    sample_means = []\n    for _ in range(num_samples):\n        if distribution_type == 'uniform':\n            sample = np.random.uniform(low=kwargs.get('low', 0), high=kwargs.get('high', 1), size=sample_size)\n        elif distribution_type == 'exponential':\n            sample = np.random.exponential(scale=kwargs.get('scale', 1), size=sample_size)\n        elif distribution_type == 'normal':\n            sample = np.random.normal(loc=kwargs.get('loc', 0), scale=kwargs.get('scale', 1), size=sample_size)\n        elif distribution_type == 'binomial':\n            sample = np.random.binomial(kwargs.get('n', 100), kwargs.get('p', 0.5), size=sample_size)\n        elif distribution_type == 'gamma':\n            sample = np.random.gamma(3, 2, size=sample_size)\n        else:\n            raise ValueError(\"Invalid distribution type.\")\n        sample_means.append(np.mean(sample))\n\n    plt.figure(figsize=(8, 6))\n    sns.histplot(sample_means, kde=True, stat=\"density\")\n    plt.title(f\"Distribution of Sample Means (n={sample_size}, {num_samples} samples)\\nFrom {distribution_type} distribution\", fontsize=14)\n    plt.xlabel(\"Sample Mean\", fontsize=12)\n    plt.ylabel(\"Density\", fontsize=12)\n    plt.show()\n    return sample_means\n\n\n# 실험 설정\ndistributions = {\n#     'uniform': {'low': 0, 'high': 1},\n#     'exponential': {'scale': 1},\n#     'normal': {'loc': 0, 'scale': 1},\n#      'binomial': {'n': 100, 'p': 0.1},\n     'gamma': {'shape': 3, 'scale': 2},\n}\n\nsample_sizes = [5, 100, 1000]\nnum_samples_list = [1000]\n\n\n#  다양한 분포, 표본 크기, 표본 개수에 대한 실험\nfor dist_name, dist_params in distributions.items():\n    for sample_size in sample_sizes:\n        for num_samples in num_samples_list:\n            print(f\"\\n--- {dist_name}, sample_size={sample_size}, num_samples={num_samples} ---\")\n            simulate_clt(dist_name, sample_size, num_samples, **dist_params)\n\n\n--- gamma, sample_size=5, num_samples=1000 ---\n\n\n/root/anaconda3/envs/pypy/lib/python3.10/site-packages/seaborn/_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  with pd.option_context('mode.use_inf_as_na', True):\n\n\n\n\n\n\n\n\n\n\n--- gamma, sample_size=100, num_samples=1000 ---\n\n\n/root/anaconda3/envs/pypy/lib/python3.10/site-packages/seaborn/_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  with pd.option_context('mode.use_inf_as_na', True):\n\n\n\n\n\n\n\n\n\n\n--- gamma, sample_size=1000, num_samples=1000 ---\n\n\n/root/anaconda3/envs/pypy/lib/python3.10/site-packages/seaborn/_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  with pd.option_context('mode.use_inf_as_na', True):\n\n\n\n\n\n\n\n\n\n- 정규분포라고 하기에는 약간 애매\n\n분포를 바꿔가면서 할 수 있음!!!\n\n\n\n2. Simulation for Confidence Interval\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm, t  # 정규분포, t-분포 사용\n\n\ndef confidence_interval_simulation(population_mean, population_std, sample_size, num_samples, confidence_level=0.95, distribution='normal'):\n    \"\"\"\n    신뢰구간 시뮬레이션 함수\n\n    Args:\n        population_mean (float): 모집단 평균\n        population_std (float): 모집단 표준편차\n        sample_size (int): 표본 크기\n        num_samples (int): 표본 추출 횟수 (시뮬레이션 반복 횟수)\n        confidence_level (float): 신뢰 수준 (default: 0.95)\n        distribution (str): 'normal' (정규분포) 또는 't' (t-분포) (default: 'normal')\n\n    Returns:\n        None (신뢰구간 시각화 및 포함 비율 출력)\n    \"\"\"\n\n    if distribution not in ['normal', 't']:\n        raise ValueError(\"distribution must be 'normal' or 't'\")\n\n    intervals_containing_mean = 0  # 모집단 평균을 포함하는 신뢰구간 개수\n    plt.figure(figsize=(10, 6))\n\n    for _ in range(num_samples):\n        # 1. 표본 추출\n        sample = np.random.normal(loc=population_mean, scale=population_std, size=sample_size)\n        sample_mean = np.mean(sample)\n        sample_std = np.std(sample, ddof=1)  # 표본 표준편차 (불편추정량, ddof=1)\n\n        # 2. 신뢰구간 계산\n        if distribution == 'normal':\n            # 정규분포 기반 (모집단 표준편차를 알 때)\n            z_critical = norm.ppf((1 + confidence_level) / 2)  # Z-critical value\n            margin_of_error = z_critical * (population_std / np.sqrt(sample_size))\n            lower_bound = sample_mean - margin_of_error\n            upper_bound = sample_mean + margin_of_error\n        else:  # distribution == 't'\n            # t-분포 기반 (모집단 표준편차를 모를 때)\n            t_critical = t.ppf((1 + confidence_level) / 2, df=sample_size - 1) # t-critical value\n            margin_of_error = t_critical * (sample_std / np.sqrt(sample_size))  # 표본표준편차 사용\n            lower_bound = sample_mean - margin_of_error\n            upper_bound = sample_mean + margin_of_error\n\n        # 3. 신뢰구간이 모집단 평균을 포함하는지 확인\n        if lower_bound &lt;= population_mean &lt;= upper_bound:\n            intervals_containing_mean += 1\n            color = 'green'  # 포함하면 파란색\n        else:\n            color = 'blue'  # 포함하지 않으면 빨간색\n\n        # 4. 신뢰구간 시각화\n        plt.plot([lower_bound, upper_bound], [_, _], color=color, alpha=0.7)\n        plt.scatter(sample_mean, _, color=color, s=10, alpha=0.7)  # 표본평균 표시\n\n    # 5. 결과 출력\n    plt.axvline(x=population_mean, color='green', linestyle='--', label=f'Population Mean ({population_mean})')  # 모집단 평균 (녹색 점선)\n    plt.title(f\"Confidence Interval Simulation ({confidence_level*100:.0f}% CI)\\n\"\n              f\"Sample Size: {sample_size},  Number of Samples: {num_samples}, Distribution: {distribution}\")\n    plt.xlabel(\"Value\")\n    plt.ylabel(\"Sample Number\")\n    plt.legend()\n    plt.show()\n\n    inclusion_rate = (intervals_containing_mean / num_samples) * 100\n    print(f\"Inclusion Rate: {inclusion_rate:.2f}%  ({intervals_containing_mean} out of {num_samples} intervals contained the population mean)\")\n\n# 시뮬레이션 실행 예시\npopulation_mean = 100  # 모집단 평균\npopulation_std = 15    # 모집단 표준편차\nsample_size = 100       # 표본 크기\nnum_samples = 100      # 표본 추출 횟수\n\n# 정규분포 기반 신뢰구간 시뮬레이션\nconfidence_interval_simulation(population_mean, population_std, sample_size, num_samples, confidence_level=0.95, distribution='normal')\n# t-분포 기반 신뢰구간 시뮬레이션 (모표준편차 모를 때)\n#confidence_interval_simulation(population_mean, population_std, sample_size, num_samples, confidence_level=0.95, distribution='t')\n\n\n\n\n\n\n\n\nInclusion Rate: 92.00%  (92 out of 100 intervals contained the population mean)\n\n\n- 코드는 몰라도 됨\n\n결과에 대한 분석만 할 줄 알면 됨\nconfidence_level 바꿔가며 실험\n표본크기 바꿔가며 실험 \\(\\to\\) 표본 크기에 따라 양상이 달라짐\n\n\n\n3. Example of indep. two sample t.test\n\nimport pandas as pd\nfrom scipy.stats import ttest_ind\nimport numpy as np\n\n# 1. 데이터 불러오기 및 확인\n\n# CSV 파일 읽기\ndf = pd.read_csv(\"GG.csv\")\nprint(\"원본 데이터:\\n\", df)\n\n# 2. 데이터 분리 및 결측치 처리\n\n# male, female 데이터를 각각 NumPy 배열로 변환\nmale_height = df['male'].to_numpy()\nfemale_height = df['female'].to_numpy()\n\n# NumPy의 isnan() 함수를 사용하여 NaN 값 제거\nmale_height_cleaned = male_height[~np.isnan(male_height)].astype(float)\nfemale_height_cleaned = female_height[~np.isnan(female_height)].astype(float)\n\nprint(\"\\n결측치 제거 후 male 키 데이터:\\n\", male_height_cleaned)\nprint(\"\\n결측치 제거 후 female 키 데이터:\\n\", female_height_cleaned)\n\n# 3. 독립표본 t-검정 (등분산 가정)\n# 귀무가설 (H0): 남학생 키의 모평균과 여학생 키의 모평균은 같다. (모분산 같음)\n# 대립가설 (H1): 남학생 키의 모평균과 여학생 키의 모평균은 다르다.\n\n# equal_var=True (등분산 가정)\nt_stat_equal, p_val_equal = ttest_ind(male_height_cleaned, female_height_cleaned, equal_var=True)\n\nprint(\"\\n--- 등분산 가정 t-검정 ---\")\nprint(\"t-statistic:\", t_stat_equal)\nprint(\"p-value:\", p_val_equal)\n\n# 결과 해석 (등분산 가정)\nalpha = 0.05  # 유의 수준\nif p_val_equal &lt; alpha:\n    print(\"등분산 가정: 귀무가설 기각 - 남녀 키 평균은 통계적으로 유의미하게 다릅니다.\")\nelse:\n    print(\"등분산 가정: 귀무가설 채택 - 남녀 키 평균은 통계적으로 유의미한 차이가 없습니다.\")\n\n# 4. 독립표본 t-검정 (이분산 가정)\n# 귀무가설 (H0): 남학생 키의 모평균과 여학생 키의 모평균은 같다. (모분산 다름)\n# 대립가설 (H1): 남학생 키의 모평균과 여학생 키의 모평균은 다르다.\n\n# equal_var=False (이분산 가정, Welch's t-test)\nt_stat_welch, p_val_welch = ttest_ind(male_height_cleaned, female_height_cleaned, equal_var=False)\n\nprint(\"\\n--- 이분산 가정 t-검정 (Welch's t-test) ---\")\nprint(\"t-statistic:\", t_stat_welch)\nprint(\"p-value:\", p_val_welch)\n\n# 결과 해석 (이분산 가정)\nif p_val_welch &lt; alpha:\n    print(\"이분산 가정: 귀무가설 기각 - 남녀 키 평균은 통계적으로 유의미하게 다릅니다.\")\nelse:\n    print(\"이분산 가정: 귀무가설 채택 - 남녀 키 평균은 통계적으로 유의미한 차이가 없습니다.\")\n\n#### 참고사항: scipy 버전에 따라 자유도가 출력될 수 있음: 각자의 컴퓨터마다 아래 결과에 \"df =\"출력될 수 있으니 돌려보기만 하면 됩니다.\n\nprint(ttest_ind(male_height_cleaned, female_height_cleaned, equal_var=True))\nprint(ttest_ind(male_height_cleaned, female_height_cleaned, equal_var=False))\n\n원본 데이터:\n     male  female\n0    114   108.0\n1     96    98.0\n2     80    88.0\n3    102    86.0\n4     94   100.0\n5     94    98.0\n6     98   104.0\n7     92   102.0\n8     94    94.0\n9    100     NaN\n10   108     NaN\n11   110     NaN\n12    90     NaN\n13    90     NaN\n14    82     NaN\n15   106     NaN\n\n결측치 제거 후 male 키 데이터:\n [114.  96.  80. 102.  94.  94.  98.  92.  94. 100. 108. 110.  90.  90.\n  82. 106.]\n\n결측치 제거 후 female 키 데이터:\n [108.  98.  88.  86. 100.  98. 104. 102.  94.]\n\n--- 등분산 가정 t-검정 ---\nt-statistic: -0.18597961132240054\np-value: 0.8540912649163084\n등분산 가정: 귀무가설 채택 - 남녀 키 평균은 통계적으로 유의미한 차이가 없습니다.\n\n--- 이분산 가정 t-검정 (Welch's t-test) ---\nt-statistic: -0.20139794503778663\np-value: 0.8423466136276512\n이분산 가정: 귀무가설 채택 - 남녀 키 평균은 통계적으로 유의미한 차이가 없습니다.\nTtestResult(statistic=-0.18597961132240054, pvalue=0.8540912649163084, df=23.0)\nTtestResult(statistic=-0.20139794503778663, pvalue=0.8423466136276512, df=20.771503751242072)\n\n\n- p-value가 너무 커서 귀무가설 기각하지 못함"
  },
  {
    "objectID": "posts/7.Prediction_Simulations2.html",
    "href": "posts/7.Prediction_Simulations2.html",
    "title": "7. Prediction Simulations 2",
    "section": "",
    "text": "# Number of simulations, samples\nn_simulations &lt;- 500\nn_train &lt;- 100\nn_test &lt;- 100\n\n# Number of predictor variables\nn_vars_total &lt;- 10\n# Number of predictor variables with non-zero true coefficients\nn_vars_true &lt;- 2\n# Number of noise variables (total - true)\nn_vars_noise &lt;- n_vars_total - n_vars_true\n\n# True regression coefficients\ntrue_beta &lt;- c(5, -3, rep(0, n_vars_noise))\n\n# True intercept\ntrue_intercept &lt;- 2\n\n# Standard deviation of the error term (noise in the Y value)\nerror_sd &lt;- 3\n\n# --- Initialization ---\nrmse_train_all &lt;- numeric(n_simulations) \nrmse_test_all &lt;- numeric(n_simulations) \n\nrmse_train_true &lt;- numeric(n_simulations) \nrmse_test_true &lt;- numeric(n_simulations)  \n\nrmse_train_plus1 &lt;- numeric(n_simulations) \nrmse_test_plus1 &lt;- numeric(n_simulations) \n\n\n# Set seed for reproducibility\nset.seed(1015)\n\n# --- Simulation Loop ---\n\n# Loop 50 times\nfor (i in 1:n_simulations) {\n  \n  # Generate predictor variables (X) from a standard normal distribution\n  X_train_matrix &lt;- matrix(rnorm(n_train * n_vars_total), nrow = n_train, ncol = n_vars_total)\n  # Generate the error term (epsilon)\n  epsilon_train &lt;- rnorm(n_train, mean = 0, sd = error_sd)\n  # Calculate the response variable (Y) using the true model: Y = intercept + X * beta + epsilon\n  Y_train_vector &lt;- true_intercept + X_train_matrix %*% true_beta + epsilon_train\n  # Combine predictors and response into a data frame (useful for lm function)\n  train_df &lt;- data.frame(Y = Y_train_vector, X_train_matrix)\n  # Assign meaningful column names\n  colnames(train_df) &lt;- c(\"Y\", paste0(\"X\", 1:n_vars_total))\n  \n  # Generate independent test data using the same process\n  X_test_matrix &lt;- matrix(rnorm(n_test * n_vars_total), nrow = n_test, ncol = n_vars_total)\n  epsilon_test &lt;- rnorm(n_test, mean = 0, sd = error_sd)\n  Y_test_vector &lt;- true_intercept + X_test_matrix %*% true_beta + epsilon_test\n  test_df &lt;- data.frame(Y = Y_test_vector, X_test_matrix)\n  colnames(test_df) &lt;- c(\"Y\", paste0(\"X\", 1:n_vars_total))\n  \n  # Model 1: Using all predictor variables\n  model_all &lt;- lm(Y ~ ., data = train_df)\n  \n  # Model 2: Using only the true predictor variables (X1 and X2 in this case)\n  true_var_names &lt;- paste0(\"X\", 1:n_vars_true)\n  formula_true_str &lt;- paste(\"Y ~\", paste(true_var_names, collapse = \" + \")) \n  formula_true &lt;- as.formula(formula_true_str)\n  model_true &lt;- lm(formula_true, data = train_df)\n  \n  # Model 3: Using true predictors + 1 randomly chosen noise predictor\n  noise_var_indices &lt;- (n_vars_true + 1):n_vars_total\n  chosen_noise_index &lt;- sample(noise_var_indices, 1)\n  chosen_noise_var_name &lt;- paste0(\"X\", chosen_noise_index)\n  vars_plus1 &lt;- c(true_var_names, chosen_noise_var_name)\n  formula_plus1_str &lt;- paste(\"Y ~\", paste(vars_plus1, collapse = \" + \")) # Create formula string\n  formula_plus1 &lt;- as.formula(formula_plus1_str) # Convert to formula\n  model_plus1 &lt;- lm(formula_plus1, data = train_df)\n  \n  # Calculate fitted values using the estimated model on the original training data\n  fitted_train_all &lt;- predict(model_all, newdata = train_df)\n  fitted_train_true &lt;- predict(model_true, newdata = train_df)\n  fitted_train_plus1 &lt;- predict(model_plus1, newdata = train_df)\n  \n  # Make predictions using the estimated model on the unseen evaluation data\n  pred_test_all &lt;- predict(model_all, newdata = eval_df)\n  pred_test_true &lt;- predict(model_true, newdata = eval_df)\n  pred_test_plus1 &lt;- predict(model_plus1, newdata = eval_df)\n  \n  # RMSE on training data (using fitted values) - Measures goodness of fit to the training data\n  rmse_train_all[i] &lt;- sqrt(mean((train_df$Y - fitted_train_all)^2))\n  rmse_train_true[i] &lt;- sqrt(mean((train_df$Y - fitted_train_true)^2))\n  rmse_train_plus1[i] &lt;- sqrt(mean((train_df$Y - fitted_train_plus1)^2))\n  \n  # RMSE on evaluation data (using predicted values) - Measures prediction accuracy on unseen data\n  rmse_test_all[i] &lt;- sqrt(mean((eval_df$Y - pred_test_all)^2))\n  rmse_test_true[i] &lt;- sqrt(mean((eval_df$Y - pred_test_true)^2))\n  rmse_test_plus1[i] &lt;- sqrt(mean((eval_df$Y - pred_test_plus1)^2))\n\n} # End of the simulation loop\n\nERROR: Error in eval(expr, envir, enclos): object 'eval_df' not found\n\nError in eval(expr, envir, enclos): object 'eval_df' not found\nTraceback:\n\n1. predict(model_all, newdata = eval_df)\n2. predict.lm(model_all, newdata = eval_df)\n\n\n\n\n# --- Step 6: Create Scatter Plots ---\npar(mfrow = c(1, 3), mar = c(4, 4, 3, 1), oma = c(0, 0, 2, 0)) # Adjust margins\n\n# Determine common axis limits for better comparison across plots\nall_rmse_values &lt;- c(rmse_train_all, rmse_test_all,\n                     rmse_train_true, rmse_test_true,\n                     rmse_train_plus1, rmse_test_plus1)\nplot_lim &lt;- range(all_rmse_values, na.rm = TRUE)\n\n# Plot 1: All Predictors\nplot(x = rmse_train_all, y = rmse_test_all,\n     main = \"Model: All Predictors\",\n     xlab = \"Training RMSE (Fit)\",       \n     ylab = \"Evaluation RMSE (Predict)\",  \n     pch = 19, col = \"dodgerblue\",\n     xlim = plot_lim, # Use common limits\n     ylim = plot_lim)\nabline(a = 0, b = 1, col = \"red\", lty = 2) # y=x line\n\n# Plot 2: True Predictors Only\nplot(x = rmse_train_true, y = rmse_test_true,\n     main = \"Model: True Predictors\",\n     xlab = \"Training RMSE\",\n     ylab = \"Test RMSE\",\n     pch = 19, col = \"forestgreen\",\n     xlim = plot_lim,\n     ylim = plot_lim)\nabline(a = 0, b = 1, col = \"red\", lty = 2)\n\n# Plot 3: True + 1 Noise Predictor\nplot(x = rmse_train_plus1, y = rmse_test_plus1,\n     main = \"Model: True + 1 Noise\",\n     xlab = \"Training RMSE (Fit)\",\n     ylab = \"Evaluation RMSE (Predict)\",\n     pch = 19, col = \"darkorange\",\n     xlim = plot_lim,\n     ylim = plot_lim)\nabline(a = 0, b = 1, col = \"red\", lty = 2)\n\n# Add an overall title to the figure\nmtext(\"Training RMSE (Goodness of Fit) vs. Evaluation RMSE (Prediction Accuracy)\", outer = TRUE, cex = 1.2) # More descriptive title\n\n# Reset plotting parameters to default (1 plot per device)\npar(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1), oma = c(0, 0, 0, 0))"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DC2025",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nApr 16, 2025\n\n\n7. Prediction Simulations 2\n\n\n이상민 \n\n\n\n\nApr 15, 2025\n\n\n6. Prediction Simulations 1\n\n\n이상민 \n\n\n\n\nApr 14, 2025\n\n\n5. Simulations ex\n\n\n이상민 \n\n\n\n\nApr 7, 2025\n\n\n4. 대수의 법칙, t-분포 ex\n\n\n이상민 \n\n\n\n\nApr 5, 2025\n\n\n3. DC HW1\n\n\n이상민 \n\n\n\n\nApr 4, 2025\n\n\n2. 상관계수 ex\n\n\n이상민 \n\n\n\n\nMar 25, 2025\n\n\n1. R distributions\n\n\n이상민 \n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/6.Prediction_Simulations1.html",
    "href": "posts/6.Prediction_Simulations1.html",
    "title": "6. Prediction Simulations 1",
    "section": "",
    "text": "# Set seed for reproducibility\nset.seed(123)\n\n# Number of repetitions for the entire process\nn_repetitions &lt;- 50\n\n# Number of data points in training and test sets\nn_samples &lt;- 100\n\n# Parameters for the Normal distribution\ntrue_mean &lt;- 3\ntrue_variance &lt;- 9\ntrue_sd &lt;- sqrt(true_variance) # rnorm uses standard deviation\n\n\n# Vector to store the Mean Squared Sum for training, test data for each repetition\ntrain_mse_results &lt;- numeric(n_repetitions)\ntest_mse_results &lt;- numeric(n_repetitions)\n\n\n# --- Start the Simulation Loop ---\n\nfor (i in 1:n_repetitions) {\n\n  # 1. Generate Training Data\n  train_data &lt;- rnorm(n_samples, mean = true_mean, sd = true_sd)\n\n  # 2. Calculate the Sample Mean from Training Data\n  train_sample_mean &lt;- mean(train_data)\n\n  # 3. Calculate MSE on Training Data\n  train_squared_diff &lt;- (train_data - train_sample_mean)^2\n  train_mse &lt;- mean(train_squared_diff)\n  train_mse_results[i] &lt;- train_mse\n\n  # 4. Generate Test Data (Evaluation Data)\n  test_data &lt;- rnorm(n_samples, mean = true_mean, sd = true_sd)\n\n  # 5. Calculate MSE on Test Data using the Training Sample Mean\n  test_squared_diff &lt;- (test_data - train_sample_mean)^2\n  test_mse &lt;- mean(test_squared_diff)\n  test_mse_results[i] &lt;- test_mse\n\n} # End of the simulation loop\n\n\n# --- Visualize the Results ---\n\nplot(train_mse_results, test_mse_results,\n     main = \"Comparison of Training MSE and Test MSE (50 Repetitions)\",\n     xlab = \"MSE on Training Data\",\n     ylab = \"MSE on Test Data\",\n     pch = 19,\n     col = \"blue\")\n\n# Add a diagonal line (y=x) for reference\nabline(a = 0, b = 1, col = \"red\", lty = 2) # lty=2 makes the line dashed\n\n# Add a legend\nlegend(\"topleft\", legend = \"y = x line\", col = \"red\", lty = 2)"
  },
  {
    "objectID": "posts/4.대수의법칙,t분포ex.html",
    "href": "posts/4.대수의법칙,t분포ex.html",
    "title": "4. 대수의 법칙, t-분포 ex",
    "section": "",
    "text": "1. 대수의 법칙\n\ncumsum(rpois(5000,3))[1:20]\n\n\n34589131719232431343741444651555860\n\n\n\n(cumsum(rpois(5000,3))/1:5000)[1:20]\n\n\n111.33333333333333222.52.7142857142857133.111111111111113.13.090909090909093333.066666666666673.1253.176470588235293.111111111111113.210526315789473.25\n\n\n\nts.plot(cumsum(rpois(5000,3))/1:5000)\n\n\n\n\n\n\n\n\n- 모평균이 3이므로 3으로 가까이 수렴하는 형태\n\n분포 종류 상관 x\n대수의 법칙\n\n\nrs=rep(0,1000)\nfor(k in 1:1000)\n    {\n    rs[k]=mean(rpois(1000*k,3))\n\n    if(k%%100 == 0) print(k)\n    }\n\n[1] 100\n[1] 200\n[1] 300\n[1] 400\n[1] 500\n[1] 600\n[1] 700\n[1] 800\n[1] 900\n[1] 1000\n\n\n\nplot(rs)\n\n\n\n\n\n\n\n\n- 표본의 크기가 커지면 더 가늘어짐\n\nrs=rep(0,1000)\nfor(k in 1:1000)\n    {\n    rs[k]=mean(rpois(2000*k,3))\n\n    if(k%%100 == 0) print(k)\n    }\n\n[1] 100\n[1] 200\n[1] 300\n[1] 400\n[1] 500\n[1] 600\n[1] 700\n[1] 800\n[1] 900\n[1] 1000\n\n\n\nplot(rs,ylim = c(2.94, 3.04))\n\n\n\n\n\n\n\n\n\n\n2. t-분포\n- t-분포 자유도에 따른 차이 시각화\n\nred : 자유도 5\nblue : 자유도 100\n자유도가 무한이면 표준정규분포로 수렴\n\n\nplot(dt(seq(-5,5,length=100),5)~seq(-5,5,length=100), type='l', col='red')\npoints(dt(seq(-5,5,length=100),100)~seq(-5,5,length=100), type='l', col='blue')"
  },
  {
    "objectID": "posts/1.R_distributions.html",
    "href": "posts/1.R_distributions.html",
    "title": "1. R distributions",
    "section": "",
    "text": "1. Normal Distribution(정규분포)\n- (Random Number Generation)\n- rnorm(n, mean, sd) -&gt; 평균 mean, 표준편차 sd 에서 n개 랜덤 추출\n\nnormal_random &lt;- rnorm(n = 10, mean = 0, sd = 1)\nprint(\"Normal Random Numbers:\")\nprint(normal_random)\n\n[1] \"Normal Random Numbers:\"\n [1] -0.72730915 -0.09955575 -2.01791946 -1.17899047  0.08952181  0.84630774\n [7]  0.34269490  0.17711561  1.02601457  0.60893424\n\n\n- (Probability Density Function - PDF)\n\n확률밀도함수\n\n\nnormal_pdf &lt;- dnorm(x = seq(-10,10,by=0.05), mean = 0, sd = 1)\nplot(seq(-10,10,by=0.05),normal_pdf, type='l', main ='Normal PDF')\n\n\n\n\n\n\n\n\n- (Cumulative Distribution Function - CDF)\n\n누적분포함수\n\n\nnormal_cdf &lt;- pnorm(q = seq(-10,10,by=0.05), mean = 0, sd = 1)\nplot(seq(-10,10,by=0.05),normal_cdf, main='Norma CDF', type='l' )\n\n\n\n\n\n\n\n\n- (Quantile Function)\n\n분위함수\n\n\nnormal_quantile &lt;- qnorm(p = 0.95, mean = 0, sd = 1)  # 95% 분위수\nprint(\"Normal Quantile at p=0.95:\")\nprint(normal_quantile)\n\n[1] \"Normal Quantile at p=0.95:\"\n[1] 1.644854\n\n\n\n\n2. Bernoulli Distribution(베르누이 분포)\n- rbinom\n\np=prob 에서\nsize번 베르누이 시행해서 성공한 횟수\nn번 반복해서 return\n\n\nbernoulli_random &lt;- rbinom(n = 10, size = 1, prob = 0.6)\nprint(\"Bernoulli Random Numbers:\")\nprint(bernoulli_random)\n\n[1] \"Bernoulli Random Numbers:\"\n [1] 1 1 1 0 0 1 1 0 1 1\n\n\n- (Probability Mass Function - PMF)\n\n확률 질량 함수\n\n\nbernoulli_pmf &lt;- dbinom(x = c(0,1), size = 1, prob = 0.6)\nbarplot(bernoulli_pmf, main ='Bernoulli pmf')\n\n\n\n\n\n\n\n\n- pbinom(q, size, prob)\n\n누적 분포 함수\n\n\nbernoulli_cdf &lt;- pbinom(q = c(0,1), size = 1, prob = 0.6)\nplot(bernoulli_cdf~c(0,1), xlim = c(-0.2, 1.2),main ='Bernoulli cdf', type='s')\n\n\n\n\n\n\n\n\n\nbernoulli_cdf &lt;- pbinom(q = c(0,1,2,3), size = 3, prob = 0.6)\nplot(bernoulli_cdf~c(0,1,2,3), xlim = c(-0.2, 3.2),main ='Bernoulli cdf', type='s')\n\n\n\n\n\n\n\n\n- (Quantile Function)\n\n분위함수\n\n\nbernoulli_quantile &lt;- qbinom(p = 0.8, size = 1, prob = 0.6)\nprint(\"Bernoulli Quantile at p=0.8:\")\nprint(bernoulli_quantile)\n\n[1] \"Bernoulli Quantile at p=0.8:\"\n[1] 1\n\n\n\n\n3. Binomial Distribution(이항분포)\n- 베르누이분포와 같은 함수지만 size를 1이 아니라 B(n,p)에서의 n으로 바꿈\n\nbinomial_random &lt;- rbinom(n = 10, size = 5, prob = 0.4)\nprint(\"Binomial Random Numbers:\")\nprint(binomial_random)\n\n[1] \"Binomial Random Numbers:\"\n [1] 2 3 3 2 3 1 1 3 3 1\n\n\n- 확률 질량 함수\n\ndbinom(x, size, prob)\n\n\nbernoulli_pmf &lt;- dbinom(x = c(0:5), size = 5, prob = 0.4)\nbarplot(bernoulli_pmf, main ='Binomial pmf')\n# 0,1,2,3,4,5 가 나올 확률\n\n\n\n\n\n\n\n\n- 이항분포의 특성상 분산이 더 작음\n\nE(X) = np\nVar(X) = npq\nq=1-p 이므로 &lt;=1\n\n\nbinomial_random &lt;- rbinom(n = 100, size = 5, prob = 0.4)\nmean(binomial_random)\nvar(binomial_random)\n\n2.21\n\n\n1.42010101010101\n\n\n- 누적 분포 함수\n\npbinom(q, size, prob)\n\n\nbinomial_cdf &lt;- pbinom(q = c(0:5), size = 5, prob = 0.4)\nplot(binomial_cdf~c(0:5), main ='Binomial cdf', xlim=c(0,5), type='s')\n\n\n\n\n\n\n\n\n- (Quantile Function)\n\n분위함수\nqbinom(p, size, prob)\n\n\nbinomial_quantile &lt;- qbinom(p = 0.7, size = 5, prob = 0.4)\nprint(\"Binomial Quantile at p=0.7:\")\nprint(binomial_quantile)\n\n[1] \"Binomial Quantile at p=0.7:\"\n[1] 3\n\n\n\n\n4. Exponential Distribution(지수분포)\n- rexp(n, rate)\n\nexponential_random &lt;- rexp(n = 10, rate = 2)\nprint(\"Exponential Random Numbers:\")\nprint(exponential_random)\n\n[1] \"Exponential Random Numbers:\"\n [1] 0.1571845 0.1074697 0.5828041 0.3155801 1.0756425 0.2600387 0.1384434\n [8] 1.6451927 0.1802277 0.3058570\n\n\n\nmean(rexp(n = 10, rate = 2))\nmean(rexp(n = 100000, rate = 10))\nmean(rexp(n = 100000, rate = 10))\n#거의 1에 근사하게 나옴\n\n0.82651321556108\n\n\n0.0997617675944707\n\n\n0.100401256810418\n\n\n- 확률 밀도 함수\n\ndexp(x, rate)\n\n\nexponential_pdf &lt;- dexp(x = seq(0, 10, length=1000), \n                        rate = 2)\nplot(exponential_pdf~c(seq(0, 10, length=1000)), \n      main=\"Exponential PDF\", type='l', xlab='x', ylab='value')\n\n\n\n\n\n\n\n\n- 누적 분포 함수\n\npexp(q, rate)\n\n\nexponential_cdf &lt;- pexp(q = seq(0, 10, length=1000), rate = 2)\nplot(exponential_cdf~c(seq(0, 10, length=1000)), \n     main=\"Exponential CDF\", type='s', xlab='x', ylab='value')\n###print(exponential_cdf)\n\n\n\n\n\n\n\n\n- (Quantile Function)\n\n분위함수\nqexp(p, rate)\n\n\nexponential_quantile &lt;- qexp(p = 0.6, rate = 2)\nprint(\"Exponential Quantile at p=0.6:\")\nprint(exponential_quantile)\n\n[1] \"Exponential Quantile at p=0.6:\"\n[1] 0.4581454\n\n\n\n\n5. Poisson Distribution(포아송 분포)\n- rpois\n\nlambda=3의 포아송 \\(\\to\\) 결과\nn=10번 반복\n\n\npoisson_random &lt;- rpois(n = 10, lambda = 3)\nprint(\"Poisson Random Numbers:\")\nprint(poisson_random)\n\n[1] \"Poisson Random Numbers:\"\n [1] 1 4 2 5 4 3 1 4 2 5\n\n\n포아송 분포를 따르는 변수의 평균과 분산이 같음\n\nmean(rpois(n=100000,lambda=3))\nvar(rpois(n=100000,lambda=3))\n\n2.99803\n\n\n2.97500698366984\n\n\n- 확률 질량 함수\n\ndpois(x,lambda)\n\n\npoisson_pmf &lt;- dpois(x = seq(0,12,1), lambda = 3)\nnames(poisson_pmf) = seq(0,12,1)\nbarplot(poisson_pmf, main=\"Poisson PMF\")\n\n\n\n\n\n\n\n\n- 누적 분포 함수\n\nppois(q, lambda)\n\n\npoisson_cdf &lt;- ppois(q = seq(0,12,1), lambda = 3)\nnames(poisson_pmf) = seq(0,12,1)\nplot(poisson_cdf~c(0:12), main=\"Poisson CDF\", xlab='x', \n    ylab='value', type='s')\n\n\n\n\n\n\n\n\n- (Quantile Function)\n\n분위함수\nqpois(p, lambda)\n\n\npoisson_quantile &lt;- qpois(p = 0.9, lambda = 3)\nprint(\"Poisson Quantile at p=0.9:\")\nprint(poisson_quantile)\n\n[1] \"Poisson Quantile at p=0.9:\"\n[1] 5\n\n\n\n- 추가\n- 감마 분포\n\n평균 : \\(\\alpha\\) x \\(\\beta\\)\n분산 : \\(\\alpha\\) x \\(\\beta^2\\)\n\n\nmean(rgamma(100000,1,3))\nvar(rgamma(100000,1,3))\n\n0.333018431858545\n\n\n0.111819570741366\n\n\n\n- ggplot\n\nlibrary(ggplot2)\nlibrary(tidyr) \n\n\nresults &lt;- data.frame(\n  Distribution = character(),\n  Value = numeric(),\n  Type = character(),  # Mean, Median, Variance를 구분하는 열 추가\n  stringsAsFactors = FALSE\n)\n\n\n# 1. Normal Distribution\nnormal_data &lt;- rnorm(n = 1000, mean = 0, sd = 1)\n\n\n# ggplot histogram \nggplot(data.frame(Value = normal_data), aes(x = Value)) +\n  geom_histogram(bins = 30, fill = \"skyblue\", color = \"black\") +  # bins: 막대 개수\n  labs(title = \"Normal Distribution Histogram\", x = \"Value\", y = \"Frequency\") +\n  theme_bw() \n\n\n\n\n\n\n\n\n\n# results \nresults &lt;- rbind(results,\n                 data.frame(Distribution = \"Normal\", Value = mean(normal_data), Type = \"Mean\"),\n                 data.frame(Distribution = \"Normal\", Value = median(normal_data), Type = \"Median\"),\n                 data.frame(Distribution = \"Normal\", Value = var(normal_data), Type = \"Variance\"))\n\n\n# 2. Bernoulli Distribution\nbernoulli_data &lt;- rbinom(n = 1000, size = 1, prob = 0.7)\n\n\n# ggplot bar plot \nggplot(data.frame(Outcome = factor(bernoulli_data)), aes(x = Outcome)) +\n  geom_bar(fill = \"coral\", color = \"black\") +\n  labs(title = \"Bernoulli Distribution Bar Plot\", x = \"Outcome (0: Failure, 1: Success)\", y = \"Frequency\") +\n  theme_bw()\n\n\n\n\n\n\n\n\n\nresults &lt;- rbind(results,\n                 data.frame(Distribution = \"Bernoulli\", Value = mean(bernoulli_data), Type = \"Mean\"),\n                 data.frame(Distribution = \"Bernoulli\", Value = median(bernoulli_data), Type = \"Median\"),\n                 data.frame(Distribution = \"Bernoulli\", Value = var(bernoulli_data), Type = \"Variance\"))\n\n\n# 3. Binomial Distribution\nbinomial_data &lt;- rbinom(n = 1000, size = 10, prob = 0.3)\n\n\n# ggplot histogram \nggplot(data.frame(Successes = binomial_data), aes(x = Successes)) +\n  geom_histogram(binwidth = 1, fill = \"lightgreen\", color = \"black\") +  # binwidth: 막대 너비\n  labs(title = \"Binomial Distribution Histogram\", x = \"Number of Successes\", y = \"Frequency\") +\n  scale_x_continuous(breaks = seq(0, 10, by = 1)) +  # x축 눈금 설정\n  theme_bw()\n\n\n\n\n\n\n\n\n\nresults &lt;- rbind(results,\n                 data.frame(Distribution = \"Binomial\", Value = mean(binomial_data), Type = \"Mean\"),\n                 data.frame(Distribution = \"Binomial\", Value = median(binomial_data), Type = \"Median\"),\n                 data.frame(Distribution = \"Binomial\", Value = var(binomial_data), Type = \"Variance\"))\n\n\n# 4. Exponential Distribution\nexponential_data &lt;- rexp(n = 1000, rate = 2)\n\n\n# ggplot histogram \nggplot(data.frame(Time = exponential_data), aes(x = Time)) +\n  geom_histogram(bins = 30, fill = \"gold\", color = \"black\") +\n  labs(title = \"Exponential Distribution Histogram\", x = \"Time\", y = \"Frequency\") +\n  theme_bw()\n\n\n\n\n\n\n\n\n\nresults &lt;- rbind(results,\n                 data.frame(Distribution = \"Exponential\", Value = mean(exponential_data), Type = \"Mean\"),\n                 data.frame(Distribution = \"Exponential\", Value = median(exponential_data), Type = \"Median\"),\n                 data.frame(Distribution = \"Exponential\", Value = var(exponential_data), Type = \"Variance\"))\n\n\n# 5. Poisson Distribution\npoisson_data &lt;- rpois(n = 1000, lambda = 5)\n\n\n# ggplot histogram \nggplot(data.frame(Events = poisson_data), aes(x = Events)) +\n  geom_histogram(binwidth = 1, fill = \"violet\", color = \"black\") +\n  labs(title = \"Poisson Distribution Histogram\", x = \"Number of Events\", y = \"Frequency\") +\n  scale_x_continuous(breaks = seq(0, max(poisson_data), by = 1)) +\n  theme_bw()\n\n\n\n\n\n\n\n\n\nresults &lt;- rbind(results,\n                 data.frame(Distribution = \"Poisson\", Value = mean(poisson_data), Type = \"Mean\"),\n                 data.frame(Distribution = \"Poisson\", Value = median(poisson_data), Type = \"Median\"),\n                 data.frame(Distribution = \"Poisson\", Value = var(poisson_data), Type = \"Variance\"))\n\n\nresults\n\n\nA data.frame: 15 × 3\n\n\nDistribution\nValue\nType\n\n\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;chr&gt;\n\n\n\n\nNormal\n0.01671411\nMean\n\n\nNormal\n0.01257944\nMedian\n\n\nNormal\n0.92430136\nVariance\n\n\nBernoulli\n0.70800000\nMean\n\n\nBernoulli\n1.00000000\nMedian\n\n\nBernoulli\n0.20694294\nVariance\n\n\nBinomial\n2.94600000\nMean\n\n\nBinomial\n3.00000000\nMedian\n\n\nBinomial\n2.10919319\nVariance\n\n\nExponential\n0.51712705\nMean\n\n\nExponential\n0.34010939\nMedian\n\n\nExponential\n0.28038007\nVariance\n\n\nPoisson\n4.93600000\nMean\n\n\nPoisson\n5.00000000\nMedian\n\n\nPoisson\n4.74464865\nVariance"
  }
]